/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2024 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include <stdint.h>

#define RCC_BASE_ADDR (0x40023800)
#define RCC_AHB1_EN_OFFSET (0x30)
#define RCC_AHB1_EN_ADDR (RCC_BASE_ADDR + RCC_AHB1_EN_OFFSET)
#define RCC_APB2_EN_OFFSET (0X44)
#define RCC_APB2_EN_ADDR (RCC_BASE_ADDR + RCC_APB2_EN_OFFSET)

#define GPIOA_BASE_ADDR (0X40020000)
#define GPIOC_BASE_ADDR (0x40020800)

#define GPIO_MODE_ADDR_OFFSET (0X00)
#define GPIO_INPUT_DATA_ADDR_OFFSET (0X10)
#define GPIO_OUTPUT_DATA_ADDR_OFFSET (0x14)

#define GPIOA_MODE_ADDR (GPIOA_BASE_ADDR + GPIO_MODE_ADDR_OFFSET)
#define GPIOA_OUTPUT_DATA_ADDR (GPIOA_BASE_ADDR + GPIO_OUTPUT_DATA_ADDR_OFFSET)
#define GPIOC_MODE_ADDR (GPIOC_BASE_ADDR + GPIO_MODE_ADDR_OFFSET)
#define GPIOC_INPUT_DATA_ADDR (GPIOC_BASE_ADDR + GPIO_INPUT_DATA_ADDR_OFFSET)

#define SYSCFG_BASE_ADDR (0x40013800)

#define SYSCFG_EXTICR4_ADDR_OFFSET (0X14)
#define SYSCFG_EXTICR4_ADDR (SYSCFG_BASE_ADDR + SYSCFG_EXTICR4_ADDR_OFFSET)

#define EXTI_BASE_ADDR (0x40013C00)

#define EXTI_IMR_ADDR EXTI_BASE_ADDR

#define EXTI_PR_ADDR_OFFSET (0X14)
#define EXTI_PR_ADDR (EXTI_BASE_ADDR + EXTI_PR_ADDR_OFFSET)

#define EXTI_RISING_TRIGGER_ADDR_OFFSET (0X08)
#define EXTI_RISING_TRIGGER_ADDR (EXTI_BASE_ADDR + EXTI_RISING_TRIGGER_ADDR_OFFSET)

void toggleLED();

int main(void)
{
	uint32_t *pRCC_AHB1_EN_ADDR = (uint32_t *) RCC_AHB1_EN_ADDR;
	uint32_t *pRCC_APB2_EN_ADDR = (uint32_t *) RCC_APB2_EN_ADDR;
	uint32_t *pGPIOA_MODE_ADDR = (uint32_t *) GPIOA_MODE_ADDR;
	uint32_t *pGPIOA_OUTPUT_DATA_ADDR = (uint32_t *) GPIOA_OUTPUT_DATA_ADDR;
	uint32_t *pGPIOC_MODE_ADDR = (uint32_t *) GPIOC_MODE_ADDR;
	uint32_t *pGPIOC_INPUT_DATA_ADDR = (uint32_t *) GPIOC_INPUT_DATA_ADDR;
	uint32_t *pSYSCFG_EXTICR4_ADDR = (uint32_t *) SYSCFG_EXTICR4_ADDR;
	uint32_t *pEXTI_RISING_TRIGGER_ADDR = (uint32_t *) EXTI_RISING_TRIGGER_ADDR;
	uint32_t *pEXTI_IMR_ADDR = (uint32_t *) EXTI_BASE_ADDR;
	uint32_t *pNVIC_IRQ_EN_ADDR = (uint32_t *) 0xE000E100;

	uint32_t buttonPressed = 0;

	// Enable clock to PA and PC
	*pRCC_AHB1_EN_ADDR |= (1 << 2);
	*pRCC_AHB1_EN_ADDR |= 1;

	// Enable clock for SYSCFG
	*pRCC_APB2_EN_ADDR |= (1 << 14);

	// Set Pin 5 on Port A to output mode
	*pGPIOA_MODE_ADDR &= ~(3 << 10);
	*pGPIOA_MODE_ADDR |= (1 << 10);

	// Set Pin 13 on Port C to input mode
	*pGPIOC_MODE_ADDR &= ~(3 << 26);

	// Enable Interrupt
	*pSYSCFG_EXTICR4_ADDR &= ~(0xf << 4);
	*pSYSCFG_EXTICR4_ADDR |= (2 << 4);

	// Edge Detection Configuration
	*pEXTI_RISING_TRIGGER_ADDR |= (1 << 13);

	// Interrupt Mask Register
	*pEXTI_IMR_ADDR |= (1 << 13);

	*pNVIC_IRQ_EN_ADDR |= (1 << 6);

//	while (1) {
//		buttonPressed = (*pGPIOC_INPUT_DATA_ADDR &= (1 << 13)) >> 13;
//		if (buttonPressed == 0) {
//			toggleLED();
//		}
//	}

    /* Loop forever */
	for(;;);
}

void toggleLED() {
	// Get current state
	uint32_t *pGPIOA_OUTPUT_DATA_ADDR = (uint32_t *) GPIOA_OUTPUT_DATA_ADDR;

	int currentState = (*pGPIOA_OUTPUT_DATA_ADDR >> 5) & 1;
	if (currentState == 0) {
		// Turn on LED
		*pGPIOA_OUTPUT_DATA_ADDR |= (1 << 5);
	} else {
		// Turn off LED
		*pGPIOA_OUTPUT_DATA_ADDR &= ~(1 << 5);
	}
}

void EXTI4_IRQHandler() {
	uint32_t *pEXTI_PR_ADDR = (uint32_t *) EXTI_PR_ADDR;
	toggleLED();

	// Clear Pending Register
	*pEXTI_PR_ADDR |= (1 << 13);

}










